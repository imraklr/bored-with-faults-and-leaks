/**
 * @file functions.h
 * @author Rakesh Kumar (rklsspty777@gmail.com)
 * @brief Functions related secure constructs.
 * @version 0.1.0
 * @date 2025-04-22
 * 
 * 
 */
#pragma once


// using macro to define function in global scope
#define fn(return_type, name, ...) return_type name (struct fn_var_ref **tos, ##__VA_ARGS__)

/**
 * @brief Encapsulates repetitive code blocks. In multithreaded contexts requiring function pointers, dedicated functions are necessary. However, for individual 
 * work units, consider leveraging lexical scoping using the macros, here the macro is lexical_function.
 * @note The function generated by this macro will contain and manage its own stack of references. So the lifetimes of those refereneces will be tied to the 
 * function only and any dynamically allocated memory regions will be freed upon function near-exit.
 * @note It is highly recommended to not ship the reference to top-of-stack to any other function manually within this function.
 */
#define lexical_function(return_type, function_name, unit_of_code, ...) return_type function_name(__VA_ARGS__) { \
    struct fn_var_ref tos = {}; \
    unit_of_code; \
    /* write freeing logic here */ \
}

/**
 * @brief Macro to create a labeled lexical scope with unit code inside it.
 * 
 */
#define lexical_labelled_scope(fn_name, unit, ...) fn_name: { unit }

/**
 * @brief Macro to create a non-labeled lexical scope with unit code inside it.
 * 
 */
#define lexical_scope(unit) { unit }

/**
 * @brief Special return macro used within a function to return a specific dynamically allocated 
 * pointer which was registered onto the stack based linked list within the function.
 * 
 */
#define lexical_return(p_fn_var_ref, p_ref) { \
}